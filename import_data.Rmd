---
output: github_document

---




```{r setup}
# remotes::install_github("cboettig/contenturi")
# remotes::install_github("cboettig/neonstore")

library(contenturi)
library(neonstore)
library(tidyverse)
library(bench)
```

[Bird counts](https://data.neonscience.org/data-products/DP1.10003.001)
[Bettle traps](https://data.neonscience.org/data-products/DP1.10022.001)
[Mosquito traps](https://data.neonscience.org/data-products/DP1.10043.001)



Create a content-based NEON store.  This function will repeatedly download NEON data as requested, but will only (locally) store files if they change.  Data available in the local
store is indicated by filename.  


```{r birds}
bench_time({
neon_store("DP1.10003.001")
neon_stack("DP1.10003.001")
})
```



```{r  beetles}
bench_time({
neon_store("DP1.10022.001")
neon_stack("DP1.10022.001")
})
```

```{r}
bench_time({
neon_store("DP1.10043.001")
neon_stack("DP1.10043.001")
})
```

```{r}
```

```{r}
reg <- neon_registry() %>% readr::read_csv()
paths <- as.character( lapply(reg$id, contenturi::retrieve) )
exists<- fs::file_exists(paths)
sum(exists)
sum(!exists)

infos <- fs::file_info(paths) 
infos %>% arrange(desc(size))
```

```{r eval = FALSE}

# Wow crash and burn trying this with pins!
#library(pins)

# set to 0 to upload as asset instead of commit (fails either way)
# options(pins.github.release = 0)
#
# board_register_github(repo = "cboettig/neon-cache")
# pin(paths, board = "github")
```

````{r}
piggyback::pb_upload(paths, 
                     include_path = FALSE, 
                     repo = "boettiger-lab/content-store",
                     tag = "data")


df <- piggyback::pb_list(repo = "boettiger-lab/content-store",  tag = "data")
```
And register these links 

```{r}
urls <- paste0("https://github.com/boettiger-lab/content-store/releases/download/data/",
      basename(paths))

contenturi::register(urls)
```


```{r}  
  br_count <- contenturi::retrieve(
    "hash://sha256/3544e9345cc9ff9e235ff49e2d446dfea1ce5fb2be2c82c66f4e58516bf8a3bd")
```

